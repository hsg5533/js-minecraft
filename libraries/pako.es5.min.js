!(function (t, e) {
  "object" == typeof exports && "undefined" != typeof module
    ? e(exports)
    : "function" == typeof define && define.amd
    ? define(["exports"], e)
    : e(
        ((t = "undefined" != typeof globalThis ? globalThis : t || self).pako =
          {})
      );
})(this, function (t) {
  "use strict";
  function e(t) {
    for (var e = t.length; --e >= 0; ) t[e] = 0;
  }
  var a = 573,
    i = new Uint8Array([
      0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5,
      5, 5, 5, 0,
    ]),
    n = new Uint8Array([
      0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10,
      11, 11, 12, 12, 13, 13,
    ]),
    r = new Uint8Array([
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7,
    ]),
    s = new Uint8Array([
      16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
    ]),
    $ = Array(576);
  e($);
  var o = Array(60);
  e(o);
  var f = Array(512);
  e(f);
  var l = Array(256);
  e(l);
  var h = Array(29);
  e(h);
  var d = Array(30);
  function _(t, e, a, i, n) {
    (this.static_tree = t),
      (this.extra_bits = e),
      (this.extra_base = a),
      (this.elems = i),
      (this.max_length = n),
      (this.has_stree = t && t.length);
  }
  function u(t, e) {
    (this.dyn_tree = t), (this.max_code = 0), (this.stat_desc = e);
  }
  e(d);
  var c,
    w,
    b,
    g,
    p,
    m,
    x,
    v,
    k = function t(e) {
      return e < 256 ? f[e] : f[256 + (e >>> 7)];
    },
    y = function t(e, a) {
      (e.pending_buf[e.pending++] = 255 & a),
        (e.pending_buf[e.pending++] = (a >>> 8) & 255);
    },
    z = function t(e, a, i) {
      e.bi_valid > 16 - i
        ? ((e.bi_buf |= (a << e.bi_valid) & 65535),
          y(e, e.bi_buf),
          (e.bi_buf = a >> (16 - e.bi_valid)),
          (e.bi_valid += i - 16))
        : ((e.bi_buf |= (a << e.bi_valid) & 65535), (e.bi_valid += i));
    },
    E = function t(e, a, i) {
      z(e, i[2 * a], i[2 * a + 1]);
    },
    R = function t(e, a) {
      var i = 0;
      do (i |= 1 & e), (e >>>= 1), (i <<= 1);
      while (--a > 0);
      return i >>> 1;
    },
    Z = function t(e) {
      16 === e.bi_valid
        ? (y(e, e.bi_buf), (e.bi_buf = 0), (e.bi_valid = 0))
        : e.bi_valid >= 8 &&
          ((e.pending_buf[e.pending++] = 255 & e.bi_buf),
          (e.bi_buf >>= 8),
          (e.bi_valid -= 8));
    },
    S = function t(e, i) {
      var n,
        r,
        s,
        $,
        o,
        f,
        l = i.dyn_tree,
        h = i.max_code,
        d = i.stat_desc.static_tree,
        _ = i.stat_desc.has_stree,
        u = i.stat_desc.extra_bits,
        c = i.stat_desc.extra_base,
        w = i.stat_desc.max_length,
        b = 0;
      for ($ = 0; $ <= 15; $++) e.bl_count[$] = 0;
      for (l[2 * e.heap[e.heap_max] + 1] = 0, n = e.heap_max + 1; n < a; n++)
        ($ = l[2 * l[2 * (r = e.heap[n]) + 1] + 1] + 1) > w && (($ = w), b++),
          (l[2 * r + 1] = $),
          !(r > h) &&
            (e.bl_count[$]++,
            (o = 0),
            r >= c && (o = u[r - c]),
            (f = l[2 * r]),
            (e.opt_len += f * ($ + o)),
            _ && (e.static_len += f * (d[2 * r + 1] + o)));
      if (0 !== b) {
        do {
          for ($ = w - 1; 0 === e.bl_count[$]; ) $--;
          e.bl_count[$]--, (e.bl_count[$ + 1] += 2), e.bl_count[w]--, (b -= 2);
        } while (b > 0);
        for ($ = w; 0 !== $; $--)
          for (r = e.bl_count[$]; 0 !== r; )
            !((s = e.heap[--n]) > h) &&
              (l[2 * s + 1] !== $ &&
                ((e.opt_len += ($ - l[2 * s + 1]) * l[2 * s]),
                (l[2 * s + 1] = $)),
              r--);
      }
    },
    D = function t(e, a, i) {
      var n,
        r,
        s = Array(16),
        $ = 0;
      for (n = 1; n <= 15; n++) s[n] = $ = ($ + i[n - 1]) << 1;
      for (r = 0; r <= a; r++) {
        var o = e[2 * r + 1];
        0 !== o && (e[2 * r] = R(s[o]++, o));
      }
    },
    A = function t() {
      var e,
        a,
        s,
        u,
        g,
        p = Array(16);
      for (u = 0, s = 0; u < 28; u++)
        for (e = 0, h[u] = s; e < 1 << i[u]; e++) l[s++] = u;
      for (l[s - 1] = u, g = 0, u = 0; u < 16; u++)
        for (e = 0, d[u] = g; e < 1 << n[u]; e++) f[g++] = u;
      for (g >>= 7; u < 30; u++)
        for (e = 0, d[u] = g << 7; e < 1 << (n[u] - 7); e++) f[256 + g++] = u;
      for (a = 0; a <= 15; a++) p[a] = 0;
      for (e = 0; e <= 143; ) ($[2 * e + 1] = 8), e++, p[8]++;
      for (; e <= 255; ) ($[2 * e + 1] = 9), e++, p[9]++;
      for (; e <= 279; ) ($[2 * e + 1] = 7), e++, p[7]++;
      for (; e <= 287; ) ($[2 * e + 1] = 8), e++, p[8]++;
      for (D($, 287, p), e = 0; e < 30; e++)
        (o[2 * e + 1] = 5), (o[2 * e] = R(e, 5));
      (c = new _($, i, 257, 286, 15)),
        (w = new _(o, n, 0, 30, 15)),
        (b = new _([], r, 0, 19, 7));
    },
    O = function t(e) {
      var a;
      for (a = 0; a < 286; a++) e.dyn_ltree[2 * a] = 0;
      for (a = 0; a < 30; a++) e.dyn_dtree[2 * a] = 0;
      for (a = 0; a < 19; a++) e.bl_tree[2 * a] = 0;
      (e.dyn_ltree[512] = 1),
        (e.opt_len = e.static_len = 0),
        (e.last_lit = e.matches = 0);
    },
    T = function t(e) {
      e.bi_valid > 8
        ? y(e, e.bi_buf)
        : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf),
        (e.bi_buf = 0),
        (e.bi_valid = 0);
    },
    F = function t(e, a, i, n) {
      T(e),
        n && (y(e, i), y(e, ~i)),
        e.pending_buf.set(e.window.subarray(a, a + i), e.pending),
        (e.pending += i);
    },
    L = function t(e, a, i, n) {
      var r = 2 * a,
        s = 2 * i;
      return e[r] < e[s] || (e[r] === e[s] && n[a] <= n[i]);
    },
    N = function t(e, a, i) {
      for (
        var n = e.heap[i], r = i << 1;
        r <= e.heap_len &&
        (r < e.heap_len && L(a, e.heap[r + 1], e.heap[r], e.depth) && r++,
        !L(a, n, e.heap[r], e.depth));

      )
        (e.heap[i] = e.heap[r]), (i = r), (r <<= 1);
      e.heap[i] = n;
    },
    B = function t(e, a, r) {
      var s,
        $,
        o,
        f,
        _ = 0;
      if (0 !== e.last_lit)
        do
          (s =
            (e.pending_buf[e.d_buf + 2 * _] << 8) |
            e.pending_buf[e.d_buf + 2 * _ + 1]),
            ($ = e.pending_buf[e.l_buf + _]),
            _++,
            0 === s
              ? E(e, $, a)
              : (E(e, (o = l[$]) + 256 + 1, a),
                0 !== (f = i[o]) && z(e, ($ -= h[o]), f),
                (o = k(--s)),
                E(e, o, r),
                0 !== (f = n[o]) && z(e, (s -= d[o]), f));
        while (_ < e.last_lit);
      E(e, 256, a);
    },
    I = function t(e, i) {
      var n,
        r,
        s,
        $ = i.dyn_tree,
        o = i.stat_desc.static_tree,
        f = i.stat_desc.has_stree,
        l = i.stat_desc.elems,
        h = -1;
      for (n = 0, e.heap_len = 0, e.heap_max = a; n < l; n++)
        0 !== $[2 * n]
          ? ((e.heap[++e.heap_len] = h = n), (e.depth[n] = 0))
          : ($[2 * n + 1] = 0);
      for (; e.heap_len < 2; )
        ($[2 * (s = e.heap[++e.heap_len] = h < 2 ? ++h : 0)] = 1),
          (e.depth[s] = 0),
          e.opt_len--,
          f && (e.static_len -= o[2 * s + 1]);
      for (i.max_code = h, n = e.heap_len >> 1; n >= 1; n--) N(e, $, n);
      s = l;
      do
        (n = e.heap[1]),
          (e.heap[1] = e.heap[e.heap_len--]),
          N(e, $, 1),
          (r = e.heap[1]),
          (e.heap[--e.heap_max] = n),
          (e.heap[--e.heap_max] = r),
          ($[2 * s] = $[2 * n] + $[2 * r]),
          (e.depth[s] =
            (e.depth[n] >= e.depth[r] ? e.depth[n] : e.depth[r]) + 1),
          ($[2 * n + 1] = $[2 * r + 1] = s),
          (e.heap[1] = s++),
          N(e, $, 1);
      while (e.heap_len >= 2);
      (e.heap[--e.heap_max] = e.heap[1]), S(e, i), D($, h, e.bl_count);
    },
    C = function t(e, a, i) {
      var n,
        r,
        s = -1,
        $ = a[1],
        o = 0,
        f = 7,
        l = 4;
      for (
        0 === $ && ((f = 138), (l = 3)), a[(i + 1) * 2 + 1] = 65535, n = 0;
        n <= i;
        n++
      )
        (r = $),
          ($ = a[(n + 1) * 2 + 1]),
          (!(++o < f) || r !== $) &&
            (o < l
              ? (e.bl_tree[2 * r] += o)
              : 0 !== r
              ? (r !== s && e.bl_tree[2 * r]++, e.bl_tree[32]++)
              : o <= 10
              ? e.bl_tree[34]++
              : e.bl_tree[36]++,
            (o = 0),
            (s = r),
            0 === $
              ? ((f = 138), (l = 3))
              : r === $
              ? ((f = 6), (l = 3))
              : ((f = 7), (l = 4)));
    },
    U = function t(e, a, i) {
      var n,
        r,
        s = -1,
        $ = a[1],
        o = 0,
        f = 7,
        l = 4;
      for (0 === $ && ((f = 138), (l = 3)), n = 0; n <= i; n++)
        if (((r = $), ($ = a[(n + 1) * 2 + 1]), !(++o < f) || r !== $)) {
          if (o < l)
            do E(e, r, e.bl_tree);
            while (0 != --o);
          else
            0 !== r
              ? (r !== s && (E(e, r, e.bl_tree), o--),
                E(e, 16, e.bl_tree),
                z(e, o - 3, 2))
              : o <= 10
              ? (E(e, 17, e.bl_tree), z(e, o - 3, 3))
              : (E(e, 18, e.bl_tree), z(e, o - 11, 7));
          (o = 0),
            (s = r),
            0 === $
              ? ((f = 138), (l = 3))
              : r === $
              ? ((f = 6), (l = 3))
              : ((f = 7), (l = 4));
        }
    },
    M = function t(e) {
      var a;
      for (
        C(e, e.dyn_ltree, e.l_desc.max_code),
          C(e, e.dyn_dtree, e.d_desc.max_code),
          I(e, e.bl_desc),
          a = 18;
        a >= 3 && 0 === e.bl_tree[2 * s[a] + 1];
        a--
      );
      return (e.opt_len += 3 * (a + 1) + 5 + 5 + 4), a;
    },
    H = function t(e, a, i, n) {
      var r;
      for (z(e, a - 257, 5), z(e, i - 1, 5), z(e, n - 4, 4), r = 0; r < n; r++)
        z(e, e.bl_tree[2 * s[r] + 1], 3);
      U(e, e.dyn_ltree, a - 1), U(e, e.dyn_dtree, i - 1);
    },
    K = function t(e) {
      var a,
        i = 4093624447;
      for (a = 0; a <= 31; a++, i >>>= 1)
        if (1 & i && 0 !== e.dyn_ltree[2 * a]) return 0;
      if (
        0 !== e.dyn_ltree[18] ||
        0 !== e.dyn_ltree[20] ||
        0 !== e.dyn_ltree[26]
      )
        return 1;
      for (a = 32; a < 256; a++) if (0 !== e.dyn_ltree[2 * a]) return 1;
      return 0;
    },
    j = !1,
    P = function t(e, a, i, n) {
      z(e, 0 + (n ? 1 : 0), 3), F(e, a, i, !0);
    },
    Y = function t(e, a, i, n) {
      var r,
        s,
        f = 0;
      e.level > 0
        ? (2 === e.strm.data_type && (e.strm.data_type = K(e)),
          I(e, e.l_desc),
          I(e, e.d_desc),
          (f = M(e)),
          (r = (e.opt_len + 3 + 7) >>> 3),
          (s = (e.static_len + 3 + 7) >>> 3) <= r && (r = s))
        : (r = s = i + 5),
        i + 4 <= r && -1 !== a
          ? P(e, a, i, n)
          : 4 === e.strategy || s === r
          ? (z(e, 2 + (n ? 1 : 0), 3), B(e, $, o))
          : (z(e, 4 + (n ? 1 : 0), 3),
            H(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, f + 1),
            B(e, e.dyn_ltree, e.dyn_dtree)),
        O(e),
        n && T(e);
    },
    G = {
      _tr_init: function t(e) {
        j || (A(), (j = !0)),
          (e.l_desc = new u(e.dyn_ltree, c)),
          (e.d_desc = new u(e.dyn_dtree, w)),
          (e.bl_desc = new u(e.bl_tree, b)),
          (e.bi_buf = 0),
          (e.bi_valid = 0),
          O(e);
      },
      _tr_stored_block: P,
      _tr_flush_block: Y,
      _tr_tally: function t(e, a, i) {
        return (
          (e.pending_buf[e.d_buf + 2 * e.last_lit] = (a >>> 8) & 255),
          (e.pending_buf[e.d_buf + 2 * e.last_lit + 1] = 255 & a),
          (e.pending_buf[e.l_buf + e.last_lit] = 255 & i),
          e.last_lit++,
          0 === a
            ? e.dyn_ltree[2 * i]++
            : (e.matches++,
              a--,
              e.dyn_ltree[(l[i] + 256 + 1) * 2]++,
              e.dyn_dtree[2 * k(a)]++),
          e.last_lit === e.lit_bufsize - 1
        );
      },
      _tr_align: function t(e) {
        z(e, 2, 3), E(e, 256, $), Z(e);
      },
    },
    X = function t(e, a, i, n) {
      for (
        var r = (65535 & e) | 0, s = ((e >>> 16) & 65535) | 0, $ = 0;
        0 !== i;

      ) {
        ($ = i > 2e3 ? 2e3 : i), (i -= $);
        do s = (s + (r = (r + a[n++]) | 0)) | 0;
        while (--$);
        (r %= 65521), (s %= 65521);
      }
      return r | (s << 16) | 0;
    },
    W = new Uint32Array(
      (function t() {
        for (var e, a = [], i = 0; i < 256; i++) {
          e = i;
          for (var n = 0; n < 8; n++)
            e = 1 & e ? 3988292384 ^ (e >>> 1) : e >>> 1;
          a[i] = e;
        }
        return a;
      })()
    ),
    q = function t(e, a, i, n) {
      var r = W,
        s = n + i;
      e ^= -1;
      for (var $ = n; $ < s; $++) e = (e >>> 8) ^ r[(e ^ a[$]) & 255];
      return -1 ^ e;
    },
    J = {
      2: "need dictionary",
      1: "stream end",
      0: "",
      "-1": "file error",
      "-2": "stream error",
      "-3": "data error",
      "-4": "insufficient memory",
      "-5": "buffer error",
      "-6": "incompatible version",
    },
    Q = {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      Z_BINARY: 0,
      Z_TEXT: 1,
      Z_UNKNOWN: 2,
      Z_DEFLATED: 8,
    },
    V = G._tr_init,
    tt = G._tr_stored_block,
    te = G._tr_flush_block,
    ta = G._tr_tally,
    ti = G._tr_align,
    tn = Q.Z_NO_FLUSH,
    tr = Q.Z_PARTIAL_FLUSH,
    ts = Q.Z_FULL_FLUSH,
    t$ = Q.Z_FINISH,
    to = Q.Z_BLOCK,
    tf = Q.Z_OK,
    tl = Q.Z_STREAM_END,
    th = Q.Z_STREAM_ERROR,
    td = Q.Z_DATA_ERROR,
    t8 = Q.Z_BUF_ERROR,
    t_ = Q.Z_DEFAULT_COMPRESSION,
    tu = Q.Z_FILTERED,
    tc = Q.Z_HUFFMAN_ONLY,
    t0 = Q.Z_RLE,
    tw = Q.Z_FIXED,
    tb = Q.Z_DEFAULT_STRATEGY,
    tg = Q.Z_UNKNOWN,
    tp = Q.Z_DEFLATED,
    tm = 573,
    tx = function t(e, a) {
      return (e.msg = J[a]), a;
    },
    tv = function t(e) {
      return (e << 1) - (e > 4 ? 9 : 0);
    },
    tk = function t(e) {
      for (var a = e.length; --a >= 0; ) e[a] = 0;
    },
    t1 = function t(e, a, i) {
      return ((a << e.hash_shift) ^ i) & e.hash_mask;
    },
    t4 = function t(e) {
      var a = e.state,
        i = a.pending;
      i > e.avail_out && (i = e.avail_out),
        0 !== i &&
          (e.output.set(
            a.pending_buf.subarray(a.pending_out, a.pending_out + i),
            e.next_out
          ),
          (e.next_out += i),
          (a.pending_out += i),
          (e.total_out += i),
          (e.avail_out -= i),
          (a.pending -= i),
          0 === a.pending && (a.pending_out = 0));
    },
    t6 = function t(e, a) {
      te(
        e,
        e.block_start >= 0 ? e.block_start : -1,
        e.strstart - e.block_start,
        a
      ),
        (e.block_start = e.strstart),
        t4(e.strm);
    },
    t3 = function t(e, a) {
      e.pending_buf[e.pending++] = a;
    },
    ty = function t(e, a) {
      (e.pending_buf[e.pending++] = (a >>> 8) & 255),
        (e.pending_buf[e.pending++] = 255 & a);
    },
    tz = function t(e, a, i, n) {
      var r = e.avail_in;
      return (r > n && (r = n), 0 === r)
        ? 0
        : ((e.avail_in -= r),
          a.set(e.input.subarray(e.next_in, e.next_in + r), i),
          1 === e.state.wrap
            ? (e.adler = X(e.adler, a, r, i))
            : 2 === e.state.wrap && (e.adler = q(e.adler, a, r, i)),
          (e.next_in += r),
          (e.total_in += r),
          r);
    },
    t2 = function t(e, a) {
      var i,
        n,
        r = e.max_chain_length,
        s = e.strstart,
        $ = e.prev_length,
        o = e.nice_match,
        f = e.strstart > e.w_size - 262 ? e.strstart - (e.w_size - 262) : 0,
        l = e.window,
        h = e.w_mask,
        d = e.prev,
        _ = e.strstart + 258,
        u = l[s + $ - 1],
        c = l[s + $];
      e.prev_length >= e.good_match && (r >>= 2),
        o > e.lookahead && (o = e.lookahead);
      do {
        if (
          l[(i = a) + $] !== c ||
          l[i + $ - 1] !== u ||
          l[i] !== l[s] ||
          l[++i] !== l[s + 1]
        )
          continue;
        (s += 2), i++;
        do;
        while (
          l[++s] === l[++i] &&
          l[++s] === l[++i] &&
          l[++s] === l[++i] &&
          l[++s] === l[++i] &&
          l[++s] === l[++i] &&
          l[++s] === l[++i] &&
          l[++s] === l[++i] &&
          l[++s] === l[++i] &&
          s < _
        );
        if (((n = 258 - (_ - s)), (s = _ - 258), n > $)) {
          if (((e.match_start = a), ($ = n), n >= o)) break;
          (u = l[s + $ - 1]), (c = l[s + $]);
        }
      } while ((a = d[a & h]) > f && 0 != --r);
      return $ <= e.lookahead ? $ : e.lookahead;
    },
    t5 = function t(e) {
      var a,
        i,
        n,
        r,
        s,
        $ = e.w_size;
      do {
        if (
          ((r = e.window_size - e.lookahead - e.strstart),
          e.strstart >= $ + ($ - 262))
        ) {
          e.window.set(e.window.subarray($, $ + $), 0),
            (e.match_start -= $),
            (e.strstart -= $),
            (e.block_start -= $),
            (a = i = e.hash_size);
          do (n = e.head[--a]), (e.head[a] = n >= $ ? n - $ : 0);
          while (--i);
          a = i = $;
          do (n = e.prev[--a]), (e.prev[a] = n >= $ ? n - $ : 0);
          while (--i);
          r += $;
        }
        if (0 === e.strm.avail_in) break;
        if (
          ((i = tz(e.strm, e.window, e.strstart + e.lookahead, r)),
          (e.lookahead += i),
          e.lookahead + e.insert >= 3)
        )
          for (
            s = e.strstart - e.insert,
              e.ins_h = e.window[s],
              e.ins_h = t1(e, e.ins_h, e.window[s + 1]);
            e.insert &&
            ((e.ins_h = t1(e, e.ins_h, e.window[s + 3 - 1])),
            (e.prev[s & e.w_mask] = e.head[e.ins_h]),
            (e.head[e.ins_h] = s),
            s++,
            e.insert--,
            !(e.lookahead + e.insert < 3));

          );
      } while (e.lookahead < 262 && 0 !== e.strm.avail_in);
    },
    tE = function t(e, a) {
      var i = 65535;
      for (i > e.pending_buf_size - 5 && (i = e.pending_buf_size - 5); ; ) {
        if (e.lookahead <= 1) {
          if ((t5(e), 0 === e.lookahead && a === tn)) return 1;
          if (0 === e.lookahead) break;
        }
        (e.strstart += e.lookahead), (e.lookahead = 0);
        var n = e.block_start + i;
        if (
          ((0 === e.strstart || e.strstart >= n) &&
            ((e.lookahead = e.strstart - n),
            (e.strstart = n),
            t6(e, !1),
            0 === e.strm.avail_out)) ||
          (e.strstart - e.block_start >= e.w_size - 262 &&
            (t6(e, !1), 0 === e.strm.avail_out))
        )
          return 1;
      }
      return ((e.insert = 0), a === t$)
        ? (t6(e, !0), 0 === e.strm.avail_out)
          ? 3
          : 4
        : (e.strstart > e.block_start && (t6(e, !1), e.strm.avail_out), 1);
    },
    tR = function t(e, a) {
      for (var i, n; ; ) {
        if (e.lookahead < 262) {
          if ((t5(e), e.lookahead < 262 && a === tn)) return 1;
          if (0 === e.lookahead) break;
        }
        if (
          ((i = 0),
          e.lookahead >= 3 &&
            ((e.ins_h = t1(e, e.ins_h, e.window[e.strstart + 3 - 1])),
            (i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h]),
            (e.head[e.ins_h] = e.strstart)),
          0 !== i &&
            e.strstart - i <= e.w_size - 262 &&
            (e.match_length = t2(e, i)),
          e.match_length >= 3)
        ) {
          if (
            ((n = ta(e, e.strstart - e.match_start, e.match_length - 3)),
            (e.lookahead -= e.match_length),
            e.match_length <= e.max_lazy_match && e.lookahead >= 3)
          ) {
            e.match_length--;
            do
              e.strstart++,
                (e.ins_h = t1(e, e.ins_h, e.window[e.strstart + 3 - 1])),
                (i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h]),
                (e.head[e.ins_h] = e.strstart);
            while (0 != --e.match_length);
            e.strstart++;
          } else
            (e.strstart += e.match_length),
              (e.match_length = 0),
              (e.ins_h = e.window[e.strstart]),
              (e.ins_h = t1(e, e.ins_h, e.window[e.strstart + 1]));
        } else
          (n = ta(e, 0, e.window[e.strstart])), e.lookahead--, e.strstart++;
        if (n && (t6(e, !1), 0 === e.strm.avail_out)) return 1;
      }
      return ((e.insert = e.strstart < 2 ? e.strstart : 2), a === t$)
        ? (t6(e, !0), 0 === e.strm.avail_out)
          ? 3
          : 4
        : e.last_lit && (t6(e, !1), 0 === e.strm.avail_out)
        ? 1
        : 2;
    },
    tZ = function t(e, a) {
      for (var i, n, r; ; ) {
        if (e.lookahead < 262) {
          if ((t5(e), e.lookahead < 262 && a === tn)) return 1;
          if (0 === e.lookahead) break;
        }
        if (
          ((i = 0),
          e.lookahead >= 3 &&
            ((e.ins_h = t1(e, e.ins_h, e.window[e.strstart + 3 - 1])),
            (i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h]),
            (e.head[e.ins_h] = e.strstart)),
          (e.prev_length = e.match_length),
          (e.prev_match = e.match_start),
          (e.match_length = 2),
          0 !== i &&
            e.prev_length < e.max_lazy_match &&
            e.strstart - i <= e.w_size - 262 &&
            ((e.match_length = t2(e, i)),
            e.match_length <= 5 &&
              (e.strategy === tu ||
                (3 === e.match_length && e.strstart - e.match_start > 4096)) &&
              (e.match_length = 2)),
          e.prev_length >= 3 && e.match_length <= e.prev_length)
        ) {
          (r = e.strstart + e.lookahead - 3),
            (n = ta(e, e.strstart - 1 - e.prev_match, e.prev_length - 3)),
            (e.lookahead -= e.prev_length - 1),
            (e.prev_length -= 2);
          do
            ++e.strstart <= r &&
              ((e.ins_h = t1(e, e.ins_h, e.window[e.strstart + 3 - 1])),
              (i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h]),
              (e.head[e.ins_h] = e.strstart));
          while (0 != --e.prev_length);
          if (
            ((e.match_available = 0),
            (e.match_length = 2),
            e.strstart++,
            n && (t6(e, !1), 0 === e.strm.avail_out))
          )
            return 1;
        } else if (e.match_available) {
          if (
            ((n = ta(e, 0, e.window[e.strstart - 1])) && t6(e, !1),
            e.strstart++,
            e.lookahead--,
            0 === e.strm.avail_out)
          )
            return 1;
        } else (e.match_available = 1), e.strstart++, e.lookahead--;
      }
      return (e.match_available &&
        ((n = ta(e, 0, e.window[e.strstart - 1])), (e.match_available = 0)),
      (e.insert = e.strstart < 2 ? e.strstart : 2),
      a === t$)
        ? (t6(e, !0), 0 === e.strm.avail_out)
          ? 3
          : 4
        : e.last_lit && (t6(e, !1), 0 === e.strm.avail_out)
        ? 1
        : 2;
    },
    t7 = function t(e, a) {
      for (var i, n, r, s, $ = e.window; ; ) {
        if (e.lookahead <= 258) {
          if ((t5(e), e.lookahead <= 258 && a === tn)) return 1;
          if (0 === e.lookahead) break;
        }
        if (
          ((e.match_length = 0),
          e.lookahead >= 3 &&
            e.strstart > 0 &&
            (n = $[(r = e.strstart - 1)]) === $[++r] &&
            n === $[++r] &&
            n === $[++r])
        ) {
          s = e.strstart + 258;
          do;
          while (
            n === $[++r] &&
            n === $[++r] &&
            n === $[++r] &&
            n === $[++r] &&
            n === $[++r] &&
            n === $[++r] &&
            n === $[++r] &&
            n === $[++r] &&
            r < s
          );
          (e.match_length = 258 - (s - r)),
            e.match_length > e.lookahead && (e.match_length = e.lookahead);
        }
        if (
          (e.match_length >= 3
            ? ((i = ta(e, 1, e.match_length - 3)),
              (e.lookahead -= e.match_length),
              (e.strstart += e.match_length),
              (e.match_length = 0))
            : ((i = ta(e, 0, e.window[e.strstart])),
              e.lookahead--,
              e.strstart++),
          i && (t6(e, !1), 0 === e.strm.avail_out))
        )
          return 1;
      }
      return ((e.insert = 0), a === t$)
        ? (t6(e, !0), 0 === e.strm.avail_out)
          ? 3
          : 4
        : e.last_lit && (t6(e, !1), 0 === e.strm.avail_out)
        ? 1
        : 2;
    },
    tS = function t(e, a) {
      for (var i; ; ) {
        if (0 === e.lookahead && (t5(e), 0 === e.lookahead)) {
          if (a === tn) return 1;
          break;
        }
        if (
          ((e.match_length = 0),
          (i = ta(e, 0, e.window[e.strstart])),
          e.lookahead--,
          e.strstart++,
          i && (t6(e, !1), 0 === e.strm.avail_out))
        )
          return 1;
      }
      return ((e.insert = 0), a === t$)
        ? (t6(e, !0), 0 === e.strm.avail_out)
          ? 3
          : 4
        : e.last_lit && (t6(e, !1), 0 === e.strm.avail_out)
        ? 1
        : 2;
    };
  function tD(t, e, a, i, n) {
    (this.good_length = t),
      (this.max_lazy = e),
      (this.nice_length = a),
      (this.max_chain = i),
      (this.func = n);
  }
  var tA = [
      new tD(0, 0, 0, 0, tE),
      new tD(4, 4, 8, 4, tR),
      new tD(4, 5, 16, 8, tR),
      new tD(4, 6, 32, 32, tR),
      new tD(4, 4, 16, 16, tZ),
      new tD(8, 16, 32, 32, tZ),
      new tD(8, 16, 128, 128, tZ),
      new tD(8, 32, 128, 256, tZ),
      new tD(32, 128, 258, 1024, tZ),
      new tD(32, 258, 258, 4096, tZ),
    ],
    tO = function t(e) {
      (e.window_size = 2 * e.w_size),
        tk(e.head),
        (e.max_lazy_match = tA[e.level].max_lazy),
        (e.good_match = tA[e.level].good_length),
        (e.nice_match = tA[e.level].nice_length),
        (e.max_chain_length = tA[e.level].max_chain),
        (e.strstart = 0),
        (e.block_start = 0),
        (e.lookahead = 0),
        (e.insert = 0),
        (e.match_length = e.prev_length = 2),
        (e.match_available = 0),
        (e.ins_h = 0);
    };
  function tT() {
    (this.strm = null),
      (this.status = 0),
      (this.pending_buf = null),
      (this.pending_buf_size = 0),
      (this.pending_out = 0),
      (this.pending = 0),
      (this.wrap = 0),
      (this.gzhead = null),
      (this.gzindex = 0),
      (this.method = tp),
      (this.last_flush = -1),
      (this.w_size = 0),
      (this.w_bits = 0),
      (this.w_mask = 0),
      (this.window = null),
      (this.window_size = 0),
      (this.prev = null),
      (this.head = null),
      (this.ins_h = 0),
      (this.hash_size = 0),
      (this.hash_bits = 0),
      (this.hash_mask = 0),
      (this.hash_shift = 0),
      (this.block_start = 0),
      (this.match_length = 0),
      (this.prev_match = 0),
      (this.match_available = 0),
      (this.strstart = 0),
      (this.match_start = 0),
      (this.lookahead = 0),
      (this.prev_length = 0),
      (this.max_chain_length = 0),
      (this.max_lazy_match = 0),
      (this.level = 0),
      (this.strategy = 0),
      (this.good_match = 0),
      (this.nice_match = 0),
      (this.dyn_ltree = new Uint16Array(2 * tm)),
      (this.dyn_dtree = new Uint16Array(122)),
      (this.bl_tree = new Uint16Array(78)),
      tk(this.dyn_ltree),
      tk(this.dyn_dtree),
      tk(this.bl_tree),
      (this.l_desc = null),
      (this.d_desc = null),
      (this.bl_desc = null),
      (this.bl_count = new Uint16Array(16)),
      (this.heap = new Uint16Array(573)),
      tk(this.heap),
      (this.heap_len = 0),
      (this.heap_max = 0),
      (this.depth = new Uint16Array(573)),
      tk(this.depth),
      (this.l_buf = 0),
      (this.lit_bufsize = 0),
      (this.last_lit = 0),
      (this.d_buf = 0),
      (this.opt_len = 0),
      (this.static_len = 0),
      (this.matches = 0),
      (this.insert = 0),
      (this.bi_buf = 0),
      (this.bi_valid = 0);
  }
  var tF,
    tL,
    tN,
    tB,
    tI,
    tC = function t(e) {
      if (!e || !e.state) return tx(e, th);
      (e.total_in = e.total_out = 0), (e.data_type = tg);
      var a = e.state;
      return (
        (a.pending = 0),
        (a.pending_out = 0),
        a.wrap < 0 && (a.wrap = -a.wrap),
        (a.status = a.wrap ? 42 : 113),
        (e.adler = 2 === a.wrap ? 0 : 1),
        (a.last_flush = tn),
        V(a),
        tf
      );
    },
    tU = function t(e) {
      var a = tC(e);
      return a === tf && tO(e.state), a;
    },
    tM = function t(e, a, i, n, r, s) {
      if (!e) return th;
      var $ = 1;
      if (
        (a === t_ && (a = 6),
        n < 0 ? (($ = 0), (n = -n)) : n > 15 && (($ = 2), (n -= 16)),
        r < 1 ||
          r > 9 ||
          i !== tp ||
          n < 8 ||
          n > 15 ||
          a < 0 ||
          a > 9 ||
          s < 0 ||
          s > tw)
      )
        return tx(e, th);
      8 === n && (n = 9);
      var o = new tT();
      return (
        (e.state = o),
        (o.strm = e),
        (o.wrap = $),
        (o.gzhead = null),
        (o.w_bits = n),
        (o.w_size = 1 << o.w_bits),
        (o.w_mask = o.w_size - 1),
        (o.hash_bits = r + 7),
        (o.hash_size = 1 << o.hash_bits),
        (o.hash_mask = o.hash_size - 1),
        (o.hash_shift = ~~((o.hash_bits + 3 - 1) / 3)),
        (o.window = new Uint8Array(2 * o.w_size)),
        (o.head = new Uint16Array(o.hash_size)),
        (o.prev = new Uint16Array(o.w_size)),
        (o.lit_bufsize = 1 << (r + 6)),
        (o.pending_buf_size = 4 * o.lit_bufsize),
        (o.pending_buf = new Uint8Array(o.pending_buf_size)),
        (o.d_buf = 1 * o.lit_bufsize),
        (o.l_buf = 3 * o.lit_bufsize),
        (o.level = a),
        (o.strategy = s),
        (o.method = i),
        tU(e)
      );
    },
    tH = {
      deflateInit: function t(e, a) {
        return tM(e, a, tp, 15, 8, tb);
      },
      deflateInit2: tM,
      deflateReset: tU,
      deflateResetKeep: tC,
      deflateSetHeader: function t(e, a) {
        return e && e.state && 2 === e.state.wrap
          ? ((e.state.gzhead = a), tf)
          : th;
      },
      deflate: function t(e, a) {
        if (!e || !e.state || a > to || a < 0) return e ? tx(e, th) : th;
        var i,
          n,
          r = e.state;
        if (
          !e.output ||
          (!e.input && 0 !== e.avail_in) ||
          (666 === r.status && a !== t$)
        )
          return tx(e, 0 === e.avail_out ? t8 : th);
        r.strm = e;
        var s = r.last_flush;
        if (((r.last_flush = a), 42 === r.status)) {
          if (2 === r.wrap)
            (e.adler = 0),
              t3(r, 31),
              t3(r, 139),
              t3(r, 8),
              r.gzhead
                ? (t3(
                    r,
                    (r.gzhead.text ? 1 : 0) +
                      (r.gzhead.hcrc ? 2 : 0) +
                      (r.gzhead.extra ? 4 : 0) +
                      (r.gzhead.name ? 8 : 0) +
                      (r.gzhead.comment ? 16 : 0)
                  ),
                  t3(r, 255 & r.gzhead.time),
                  t3(r, (r.gzhead.time >> 8) & 255),
                  t3(r, (r.gzhead.time >> 16) & 255),
                  t3(r, (r.gzhead.time >> 24) & 255),
                  t3(
                    r,
                    9 === r.level ? 2 : r.strategy >= tc || r.level < 2 ? 4 : 0
                  ),
                  t3(r, 255 & r.gzhead.os),
                  r.gzhead.extra &&
                    r.gzhead.extra.length &&
                    (t3(r, 255 & r.gzhead.extra.length),
                    t3(r, (r.gzhead.extra.length >> 8) & 255)),
                  r.gzhead.hcrc &&
                    (e.adler = q(e.adler, r.pending_buf, r.pending, 0)),
                  (r.gzindex = 0),
                  (r.status = 69))
                : (t3(r, 0),
                  t3(r, 0),
                  t3(r, 0),
                  t3(r, 0),
                  t3(r, 0),
                  t3(
                    r,
                    9 === r.level ? 2 : r.strategy >= tc || r.level < 2 ? 4 : 0
                  ),
                  t3(r, 3),
                  (r.status = 113));
          else {
            var $ = (tp + ((r.w_bits - 8) << 4)) << 8,
              o = -1;
            ($ |=
              (o =
                r.strategy >= tc || r.level < 2
                  ? 0
                  : r.level < 6
                  ? 1
                  : 6 === r.level
                  ? 2
                  : 3) << 6),
              0 !== r.strstart && ($ |= 32),
              ($ += 31 - ($ % 31)),
              (r.status = 113),
              ty(r, $),
              0 !== r.strstart &&
                (ty(r, e.adler >>> 16), ty(r, 65535 & e.adler)),
              (e.adler = 1);
          }
        }
        if (69 === r.status) {
          if (r.gzhead.extra) {
            for (
              i = r.pending;
              r.gzindex < (65535 & r.gzhead.extra.length) &&
              (r.pending !== r.pending_buf_size ||
                (r.gzhead.hcrc &&
                  r.pending > i &&
                  (e.adler = q(e.adler, r.pending_buf, r.pending - i, i)),
                t4(e),
                (i = r.pending),
                r.pending !== r.pending_buf_size));

            )
              t3(r, 255 & r.gzhead.extra[r.gzindex]), r.gzindex++;
            r.gzhead.hcrc &&
              r.pending > i &&
              (e.adler = q(e.adler, r.pending_buf, r.pending - i, i)),
              r.gzindex === r.gzhead.extra.length &&
                ((r.gzindex = 0), (r.status = 73));
          } else r.status = 73;
        }
        if (73 === r.status) {
          if (r.gzhead.name) {
            i = r.pending;
            do {
              if (
                r.pending === r.pending_buf_size &&
                (r.gzhead.hcrc &&
                  r.pending > i &&
                  (e.adler = q(e.adler, r.pending_buf, r.pending - i, i)),
                t4(e),
                (i = r.pending),
                r.pending === r.pending_buf_size)
              ) {
                n = 1;
                break;
              }
              (n =
                r.gzindex < r.gzhead.name.length
                  ? 255 & r.gzhead.name.charCodeAt(r.gzindex++)
                  : 0),
                t3(r, n);
            } while (0 !== n);
            r.gzhead.hcrc &&
              r.pending > i &&
              (e.adler = q(e.adler, r.pending_buf, r.pending - i, i)),
              0 === n && ((r.gzindex = 0), (r.status = 91));
          } else r.status = 91;
        }
        if (91 === r.status) {
          if (r.gzhead.comment) {
            i = r.pending;
            do {
              if (
                r.pending === r.pending_buf_size &&
                (r.gzhead.hcrc &&
                  r.pending > i &&
                  (e.adler = q(e.adler, r.pending_buf, r.pending - i, i)),
                t4(e),
                (i = r.pending),
                r.pending === r.pending_buf_size)
              ) {
                n = 1;
                break;
              }
              (n =
                r.gzindex < r.gzhead.comment.length
                  ? 255 & r.gzhead.comment.charCodeAt(r.gzindex++)
                  : 0),
                t3(r, n);
            } while (0 !== n);
            r.gzhead.hcrc &&
              r.pending > i &&
              (e.adler = q(e.adler, r.pending_buf, r.pending - i, i)),
              0 === n && (r.status = 103);
          } else r.status = 103;
        }
        if (
          (103 === r.status &&
            (r.gzhead.hcrc
              ? (r.pending + 2 > r.pending_buf_size && t4(e),
                r.pending + 2 <= r.pending_buf_size &&
                  (t3(r, 255 & e.adler),
                  t3(r, (e.adler >> 8) & 255),
                  (e.adler = 0),
                  (r.status = 113)))
              : (r.status = 113)),
          0 !== r.pending)
        ) {
          if ((t4(e), 0 === e.avail_out)) return (r.last_flush = -1), tf;
        } else if (0 === e.avail_in && tv(a) <= tv(s) && a !== t$)
          return tx(e, t8);
        if (666 === r.status && 0 !== e.avail_in) return tx(e, t8);
        if (
          0 !== e.avail_in ||
          0 !== r.lookahead ||
          (a !== tn && 666 !== r.status)
        ) {
          var f =
            r.strategy === tc
              ? tS(r, a)
              : r.strategy === t0
              ? t7(r, a)
              : tA[r.level].func(r, a);
          if (((3 === f || 4 === f) && (r.status = 666), 1 === f || 3 === f))
            return 0 === e.avail_out && (r.last_flush = -1), tf;
          if (
            2 === f &&
            (a === tr
              ? ti(r)
              : a !== to &&
                (tt(r, 0, 0, !1),
                a === ts &&
                  (tk(r.head),
                  0 === r.lookahead &&
                    ((r.strstart = 0), (r.block_start = 0), (r.insert = 0)))),
            t4(e),
            0 === e.avail_out)
          )
            return (r.last_flush = -1), tf;
        }
        return a !== t$
          ? tf
          : r.wrap <= 0
          ? tl
          : (2 === r.wrap
              ? (t3(r, 255 & e.adler),
                t3(r, (e.adler >> 8) & 255),
                t3(r, (e.adler >> 16) & 255),
                t3(r, (e.adler >> 24) & 255),
                t3(r, 255 & e.total_in),
                t3(r, (e.total_in >> 8) & 255),
                t3(r, (e.total_in >> 16) & 255),
                t3(r, (e.total_in >> 24) & 255))
              : (ty(r, e.adler >>> 16), ty(r, 65535 & e.adler)),
            t4(e),
            r.wrap > 0 && (r.wrap = -r.wrap),
            0 !== r.pending ? tf : tl);
      },
      deflateEnd: function t(e) {
        if (!e || !e.state) return th;
        var a = e.state.status;
        return 42 !== a &&
          69 !== a &&
          73 !== a &&
          91 !== a &&
          103 !== a &&
          113 !== a &&
          666 !== a
          ? tx(e, th)
          : ((e.state = null), 113 === a ? tx(e, td) : tf);
      },
      deflateSetDictionary: function t(e, a) {
        var i = a.length;
        if (!e || !e.state) return th;
        var n = e.state,
          r = n.wrap;
        if (2 === r || (1 === r && 42 !== n.status) || n.lookahead) return th;
        if (
          (1 === r && (e.adler = X(e.adler, a, i, 0)),
          (n.wrap = 0),
          i >= n.w_size)
        ) {
          0 === r &&
            (tk(n.head), (n.strstart = 0), (n.block_start = 0), (n.insert = 0));
          var s = new Uint8Array(n.w_size);
          s.set(a.subarray(i - n.w_size, i), 0), (a = s), (i = n.w_size);
        }
        var $ = e.avail_in,
          o = e.next_in,
          f = e.input;
        for (
          e.avail_in = i, e.next_in = 0, e.input = a, t5(n);
          n.lookahead >= 3;

        ) {
          var l = n.strstart,
            h = n.lookahead - 2;
          do
            (n.ins_h = t1(n, n.ins_h, n.window[l + 3 - 1])),
              (n.prev[l & n.w_mask] = n.head[n.ins_h]),
              (n.head[n.ins_h] = l),
              l++;
          while (--h);
          (n.strstart = l), (n.lookahead = 2), t5(n);
        }
        return (
          (n.strstart += n.lookahead),
          (n.block_start = n.strstart),
          (n.insert = n.lookahead),
          (n.lookahead = 0),
          (n.match_length = n.prev_length = 2),
          (n.match_available = 0),
          (e.next_in = o),
          (e.input = f),
          (e.avail_in = $),
          (n.wrap = r),
          tf
        );
      },
      deflateInfo: "pako deflate (from Nodeca project)",
    };
  function tK(t) {
    return (tK =
      "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
        ? function (t) {
            return typeof t;
          }
        : function (t) {
            return t &&
              "function" == typeof Symbol &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t;
          })(t);
  }
  var tj = {
      assign: function t(e) {
        for (var a = Array.prototype.slice.call(arguments, 1); a.length; ) {
          var i,
            n,
            r = a.shift();
          if (r) {
            if ("object" !== tK(r)) throw TypeError(r + "must be non-object");
            for (var s in r)
              (i = r),
                (n = s),
                Object.prototype.hasOwnProperty.call(i, n) && (e[s] = r[s]);
          }
        }
        return e;
      },
      flattenChunks: function t(e) {
        for (var a = 0, i = 0, n = e.length; i < n; i++) a += e[i].length;
        for (
          var r = new Uint8Array(a), s = 0, $ = 0, o = e.length;
          s < o;
          s++
        ) {
          var f = e[s];
          r.set(f, $), ($ += f.length);
        }
        return r;
      },
    },
    tP = !0;
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (tY) {
    tP = !1;
  }
  for (var tG = new Uint8Array(256), tX = 0; tX < 256; tX++)
    tG[tX] =
      tX >= 252
        ? 6
        : tX >= 248
        ? 5
        : tX >= 240
        ? 4
        : tX >= 224
        ? 3
        : tX >= 192
        ? 2
        : 1;
  tG[254] = tG[254] = 1;
  var tW = function t(e, a) {
      if (a < 65534 && e.subarray && tP)
        return String.fromCharCode.apply(
          null,
          e.length === a ? e : e.subarray(0, a)
        );
      for (var i = "", n = 0; n < a; n++) i += String.fromCharCode(e[n]);
      return i;
    },
    tq = {
      string2buf: function t(e) {
        if ("function" == typeof TextEncoder && TextEncoder.prototype.encode)
          return new TextEncoder().encode(e);
        var a,
          i,
          n,
          r,
          s,
          $ = e.length,
          o = 0;
        for (r = 0; r < $; r++)
          (64512 & (i = e.charCodeAt(r))) == 55296 &&
            r + 1 < $ &&
            (64512 & (n = e.charCodeAt(r + 1))) == 56320 &&
            ((i = 65536 + ((i - 55296) << 10) + (n - 56320)), r++),
            (o += i < 128 ? 1 : i < 2048 ? 2 : i < 65536 ? 3 : 4);
        for (s = 0, a = new Uint8Array(o), r = 0; s < o; r++)
          (64512 & (i = e.charCodeAt(r))) == 55296 &&
            r + 1 < $ &&
            (64512 & (n = e.charCodeAt(r + 1))) == 56320 &&
            ((i = 65536 + ((i - 55296) << 10) + (n - 56320)), r++),
            i < 128
              ? (a[s++] = i)
              : i < 2048
              ? ((a[s++] = 192 | (i >>> 6)), (a[s++] = 128 | (63 & i)))
              : i < 65536
              ? ((a[s++] = 224 | (i >>> 12)),
                (a[s++] = 128 | ((i >>> 6) & 63)),
                (a[s++] = 128 | (63 & i)))
              : ((a[s++] = 240 | (i >>> 18)),
                (a[s++] = 128 | ((i >>> 12) & 63)),
                (a[s++] = 128 | ((i >>> 6) & 63)),
                (a[s++] = 128 | (63 & i)));
        return a;
      },
      buf2string: function t(e, a) {
        var i,
          n,
          r = a || e.length;
        if ("function" == typeof TextDecoder && TextDecoder.prototype.decode)
          return new TextDecoder().decode(e.subarray(0, a));
        var s = Array(2 * r);
        for (n = 0, i = 0; i < r; ) {
          var $ = e[i++];
          if ($ < 128) {
            s[n++] = $;
            continue;
          }
          var o = tG[$];
          if (o > 4) {
            (s[n++] = 65533), (i += o - 1);
            continue;
          }
          for ($ &= 2 === o ? 31 : 3 === o ? 15 : 7; o > 1 && i < r; )
            ($ = ($ << 6) | (63 & e[i++])), o--;
          if (o > 1) {
            s[n++] = 65533;
            continue;
          }
          $ < 65536
            ? (s[n++] = $)
            : (($ -= 65536),
              (s[n++] = 55296 | (($ >> 10) & 1023)),
              (s[n++] = 56320 | (1023 & $)));
        }
        return tW(s, n);
      },
      utf8border: function t(e, a) {
        (a = a || e.length) > e.length && (a = e.length);
        for (var i = a - 1; i >= 0 && (192 & e[i]) == 128; ) i--;
        return i < 0 || 0 === i ? a : i + tG[e[i]] > a ? i : a;
      },
    },
    tJ = function t() {
      (this.input = null),
        (this.next_in = 0),
        (this.avail_in = 0),
        (this.total_in = 0),
        (this.output = null),
        (this.next_out = 0),
        (this.avail_out = 0),
        (this.total_out = 0),
        (this.msg = ""),
        (this.state = null),
        (this.data_type = 2),
        (this.adler = 0);
    },
    tQ = Object.prototype.toString,
    tV = Q.Z_NO_FLUSH,
    t9 = Q.Z_SYNC_FLUSH,
    et = Q.Z_FULL_FLUSH,
    ee = Q.Z_FINISH,
    ea = Q.Z_OK,
    ei = Q.Z_STREAM_END,
    en = Q.Z_DEFAULT_COMPRESSION,
    er = Q.Z_DEFAULT_STRATEGY,
    es = Q.Z_DEFLATED;
  function e$(t) {
    this.options = tj.assign(
      {
        level: en,
        method: es,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: er,
      },
      t || {}
    );
    var e,
      a = this.options;
    a.raw && a.windowBits > 0
      ? (a.windowBits = -a.windowBits)
      : a.gzip && a.windowBits > 0 && a.windowBits < 16 && (a.windowBits += 16),
      (this.err = 0),
      (this.msg = ""),
      (this.ended = !1),
      (this.chunks = []),
      (this.strm = new tJ()),
      (this.strm.avail_out = 0);
    var i = tH.deflateInit2(
      this.strm,
      a.level,
      a.method,
      a.windowBits,
      a.memLevel,
      a.strategy
    );
    if (i !== ea) throw Error(J[i]);
    if ((a.header && tH.deflateSetHeader(this.strm, a.header), a.dictionary)) {
      if (
        ((e =
          "string" == typeof a.dictionary
            ? tq.string2buf(a.dictionary)
            : "[object ArrayBuffer]" === tQ.call(a.dictionary)
            ? new Uint8Array(a.dictionary)
            : a.dictionary),
        (i = tH.deflateSetDictionary(this.strm, e)) !== ea)
      )
        throw Error(J[i]);
      this._dict_set = !0;
    }
  }
  function eo(t, e) {
    var a = new e$(e);
    if ((a.push(t, !0), a.err)) throw a.msg || J[a.err];
    return a.result;
  }
  (e$.prototype.push = function (t, e) {
    var a,
      i,
      n = this.strm,
      r = this.options.chunkSize;
    if (this.ended) return !1;
    for (
      i = e === ~~e ? e : !0 === e ? ee : tV,
        "string" == typeof t
          ? (n.input = tq.string2buf(t))
          : "[object ArrayBuffer]" === tQ.call(t)
          ? (n.input = new Uint8Array(t))
          : (n.input = t),
        n.next_in = 0,
        n.avail_in = n.input.length;
      ;

    ) {
      if (
        (0 === n.avail_out &&
          ((n.output = new Uint8Array(r)), (n.next_out = 0), (n.avail_out = r)),
        (i === t9 || i === et) && n.avail_out <= 6)
      ) {
        this.onData(n.output.subarray(0, n.next_out)), (n.avail_out = 0);
        continue;
      }
      if ((a = tH.deflate(n, i)) === ei)
        return (
          n.next_out > 0 && this.onData(n.output.subarray(0, n.next_out)),
          (a = tH.deflateEnd(this.strm)),
          this.onEnd(a),
          (this.ended = !0),
          a === ea
        );
      if (0 === n.avail_out) {
        this.onData(n.output);
        continue;
      }
      if (i > 0 && n.next_out > 0) {
        this.onData(n.output.subarray(0, n.next_out)), (n.avail_out = 0);
        continue;
      }
      if (0 === n.avail_in) break;
    }
    return !0;
  }),
    (e$.prototype.onData = function (t) {
      this.chunks.push(t);
    }),
    (e$.prototype.onEnd = function (t) {
      t === ea && (this.result = tj.flattenChunks(this.chunks)),
        (this.chunks = []),
        (this.err = t),
        (this.msg = this.strm.msg);
    });
  var ef = function t(e, a) {
      return ((a = a || {}).raw = !0), eo(e, a);
    },
    el = function t(e, a) {
      return ((a = a || {}).gzip = !0), eo(e, a);
    },
    eh = { Deflate: e$, deflate: eo, deflateRaw: ef, gzip: el, constants: Q },
    ed = function t(e, a) {
      var i,
        n,
        r,
        s,
        $,
        o,
        f,
        l,
        h,
        d,
        _,
        u,
        c,
        w,
        b,
        g,
        p,
        m,
        x,
        v,
        k,
        y,
        z,
        E,
        R = e.state;
      (i = e.next_in),
        (z = e.input),
        (n = i + (e.avail_in - 5)),
        (r = e.next_out),
        (E = e.output),
        (s = r - (a - e.avail_out)),
        ($ = r + (e.avail_out - 257)),
        (o = R.dmax),
        (f = R.wsize),
        (l = R.whave),
        (h = R.wnext),
        (d = R.window),
        (_ = R.hold),
        (u = R.bits),
        (c = R.lencode),
        (w = R.distcode),
        (b = (1 << R.lenbits) - 1),
        (g = (1 << R.distbits) - 1);
      top: do {
        u < 15 && ((_ += z[i++] << u), (u += 8), (_ += z[i++] << u), (u += 8)),
          (p = c[_ & b]);
        dolen: for (;;) {
          if (((_ >>>= m = p >>> 24), (u -= m), 0 == (m = (p >>> 16) & 255)))
            E[r++] = 65535 & p;
          else if (16 & m) {
            (x = 65535 & p),
              (m &= 15) &&
                (u < m && ((_ += z[i++] << u), (u += 8)),
                (x += _ & ((1 << m) - 1)),
                (_ >>>= m),
                (u -= m)),
              u < 15 &&
                ((_ += z[i++] << u), (u += 8), (_ += z[i++] << u), (u += 8)),
              (p = w[_ & g]);
            dodist: for (;;) {
              if (
                ((_ >>>= m = p >>> 24), (u -= m), 16 & (m = (p >>> 16) & 255))
              ) {
                if (
                  ((v = 65535 & p),
                  u < (m &= 15) &&
                    ((_ += z[i++] << u),
                    (u += 8) < m && ((_ += z[i++] << u), (u += 8))),
                  (v += _ & ((1 << m) - 1)) > o)
                ) {
                  (e.msg = "invalid distance too far back"), (R.mode = 30);
                  break top;
                }
                if (((_ >>>= m), (u -= m), v > (m = r - s))) {
                  if ((m = v - m) > l && R.sane) {
                    (e.msg = "invalid distance too far back"), (R.mode = 30);
                    break top;
                  }
                  if (((k = 0), (y = d), 0 === h)) {
                    if (((k += f - m), m < x)) {
                      x -= m;
                      do E[r++] = d[k++];
                      while (--m);
                      (k = r - v), (y = E);
                    }
                  } else if (h < m) {
                    if (((k += f + h - m), (m -= h) < x)) {
                      x -= m;
                      do E[r++] = d[k++];
                      while (--m);
                      if (((k = 0), h < x)) {
                        x -= m = h;
                        do E[r++] = d[k++];
                        while (--m);
                        (k = r - v), (y = E);
                      }
                    }
                  } else if (((k += h - m), m < x)) {
                    x -= m;
                    do E[r++] = d[k++];
                    while (--m);
                    (k = r - v), (y = E);
                  }
                  for (; x > 2; )
                    (E[r++] = y[k++]),
                      (E[r++] = y[k++]),
                      (E[r++] = y[k++]),
                      (x -= 3);
                  x && ((E[r++] = y[k++]), x > 1 && (E[r++] = y[k++]));
                } else {
                  k = r - v;
                  do
                    (E[r++] = E[k++]),
                      (E[r++] = E[k++]),
                      (E[r++] = E[k++]),
                      (x -= 3);
                  while (x > 2);
                  x && ((E[r++] = E[k++]), x > 1 && (E[r++] = E[k++]));
                }
              } else if ((64 & m) == 0) {
                p = w[(65535 & p) + (_ & ((1 << m) - 1))];
                continue dodist;
              } else {
                (e.msg = "invalid distance code"), (R.mode = 30);
                break top;
              }
              break;
            }
          } else if ((64 & m) == 0) {
            p = c[(65535 & p) + (_ & ((1 << m) - 1))];
            continue dolen;
          } else if (32 & m) {
            R.mode = 12;
            break top;
          } else {
            (e.msg = "invalid literal/length code"), (R.mode = 30);
            break top;
          }
          break;
        }
      } while (i < n && r < $);
      (i -= x = u >> 3),
        (u -= x << 3),
        (_ &= (1 << u) - 1),
        (e.next_in = i),
        (e.next_out = r),
        (e.avail_in = i < n ? 5 + (n - i) : 5 - (i - n)),
        (e.avail_out = r < $ ? 257 + ($ - r) : 257 - (r - $)),
        (R.hold = _),
        (R.bits = u);
    },
    e8 = new Uint16Array([
      3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59,
      67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0,
    ]),
    e_ = new Uint8Array([
      16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19,
      19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78,
    ]),
    eu = new Uint16Array([
      1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513,
      769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0,
    ]),
    ec = new Uint8Array([
      16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23,
      24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64,
    ]),
    e0 = function t(e, a, i, n, r, s, $, o) {
      var f,
        l,
        h,
        d,
        _,
        u,
        c,
        w,
        b,
        g = o.bits,
        p = 0,
        m = 0,
        x = 0,
        v = 0,
        k = 0,
        y = 0,
        z = 0,
        E = 0,
        R = 0,
        Z = 0,
        S = null,
        D = 0,
        A = new Uint16Array(16),
        O = new Uint16Array(16),
        T = null,
        F = 0;
      for (p = 0; p <= 15; p++) A[p] = 0;
      for (m = 0; m < n; m++) A[a[i + m]]++;
      for (v = 15, k = g; v >= 1 && 0 === A[v]; v--);
      if ((k > v && (k = v), 0 === v))
        return (r[s++] = 20971520), (r[s++] = 20971520), (o.bits = 1), 0;
      for (x = 1; x < v && 0 === A[x]; x++);
      for (k < x && (k = x), E = 1, p = 1; p <= 15; p++)
        if (((E <<= 1), (E -= A[p]) < 0)) return -1;
      if (E > 0 && (0 === e || 1 !== v)) return -1;
      for (p = 1, O[1] = 0; p < 15; p++) O[p + 1] = O[p] + A[p];
      for (m = 0; m < n; m++) 0 !== a[i + m] && ($[O[a[i + m]]++] = m);
      if (
        (0 === e
          ? ((S = T = $), (u = 19))
          : 1 === e
          ? ((S = e8), (D -= 257), (T = e_), (F -= 257), (u = 256))
          : ((S = eu), (T = ec), (u = -1)),
        (Z = 0),
        (m = 0),
        (p = x),
        (_ = s),
        (y = k),
        (z = 0),
        (h = -1),
        (d = (R = 1 << k) - 1),
        (1 === e && R > 852) || (2 === e && R > 592))
      )
        return 1;
      for (;;) {
        (c = p - z),
          $[m] < u
            ? ((w = 0), (b = $[m]))
            : $[m] > u
            ? ((w = T[F + $[m]]), (b = S[D + $[m]]))
            : ((w = 96), (b = 0)),
          (f = 1 << (p - z)),
          (x = l = 1 << y);
        do r[_ + (Z >> z) + (l -= f)] = (c << 24) | (w << 16) | b | 0;
        while (0 !== l);
        for (f = 1 << (p - 1); Z & f; ) f >>= 1;
        if ((0 !== f ? ((Z &= f - 1), (Z += f)) : (Z = 0), m++, 0 == --A[p])) {
          if (p === v) break;
          p = a[i + $[m]];
        }
        if (p > k && (Z & d) !== h) {
          for (
            0 === z && (z = k), _ += x, E = 1 << (y = p - z);
            y + z < v && !((E -= A[y + z]) <= 0);

          )
            y++, (E <<= 1);
          if (((R += 1 << y), (1 === e && R > 852) || (2 === e && R > 592)))
            return 1;
          r[(h = Z & d)] = (k << 24) | (y << 16) | (_ - s) | 0;
        }
      }
      return 0 !== Z && (r[_ + Z] = ((p - z) << 24) | 4194304), (o.bits = k), 0;
    },
    ew = Q.Z_FINISH,
    eb = Q.Z_BLOCK,
    eg = Q.Z_TREES,
    ep = Q.Z_OK,
    em = Q.Z_STREAM_END,
    ex = Q.Z_NEED_DICT,
    ev = Q.Z_STREAM_ERROR,
    ek = Q.Z_DATA_ERROR,
    e1 = Q.Z_MEM_ERROR,
    e4 = Q.Z_BUF_ERROR,
    e6 = Q.Z_DEFLATED,
    e3 = function t(e) {
      return (
        ((e >>> 24) & 255) +
        ((e >>> 8) & 65280) +
        ((65280 & e) << 8) +
        ((255 & e) << 24)
      );
    };
  function ey() {
    (this.mode = 0),
      (this.last = !1),
      (this.wrap = 0),
      (this.havedict = !1),
      (this.flags = 0),
      (this.dmax = 0),
      (this.check = 0),
      (this.total = 0),
      (this.head = null),
      (this.wbits = 0),
      (this.wsize = 0),
      (this.whave = 0),
      (this.wnext = 0),
      (this.window = null),
      (this.hold = 0),
      (this.bits = 0),
      (this.length = 0),
      (this.offset = 0),
      (this.extra = 0),
      (this.lencode = null),
      (this.distcode = null),
      (this.lenbits = 0),
      (this.distbits = 0),
      (this.ncode = 0),
      (this.nlen = 0),
      (this.ndist = 0),
      (this.have = 0),
      (this.next = null),
      (this.lens = new Uint16Array(320)),
      (this.work = new Uint16Array(288)),
      (this.lendyn = null),
      (this.distdyn = null),
      (this.sane = 0),
      (this.back = 0),
      (this.was = 0);
  }
  var ez,
    e2,
    e5,
    eE,
    eR,
    eZ = function t(e) {
      if (!e || !e.state) return ev;
      var a = e.state;
      return (
        (e.total_in = e.total_out = a.total = 0),
        (e.msg = ""),
        a.wrap && (e.adler = 1 & a.wrap),
        (a.mode = 1),
        (a.last = 0),
        (a.havedict = 0),
        (a.dmax = 32768),
        (a.head = null),
        (a.hold = 0),
        (a.bits = 0),
        (a.lencode = a.lendyn = new Int32Array(852)),
        (a.distcode = a.distdyn = new Int32Array(592)),
        (a.sane = 1),
        (a.back = -1),
        ep
      );
    },
    e7 = function t(e) {
      if (!e || !e.state) return ev;
      var a = e.state;
      return (a.wsize = 0), (a.whave = 0), (a.wnext = 0), eZ(e);
    },
    eS = function t(e, a) {
      if (!e || !e.state) return ev;
      var i,
        n = e.state;
      return (a < 0
        ? ((i = 0), (a = -a))
        : ((i = (a >> 4) + 1), a < 48 && (a &= 15)),
      a && (a < 8 || a > 15))
        ? ev
        : (null !== n.window && n.wbits !== a && (n.window = null),
          (n.wrap = i),
          (n.wbits = a),
          e7(e));
    },
    eD = function t(e, a) {
      if (!e) return ev;
      var i = new ey();
      (e.state = i), (i.window = null);
      var n = eS(e, a);
      return n !== ep && (e.state = null), n;
    },
    eA = !0,
    eO = function t(e) {
      if (eA) {
        (g = new Int32Array(512)), (p = new Int32Array(32));
        for (var a = 0; a < 144; ) e.lens[a++] = 8;
        for (; a < 256; ) e.lens[a++] = 9;
        for (; a < 280; ) e.lens[a++] = 7;
        for (; a < 288; ) e.lens[a++] = 8;
        for (e0(1, e.lens, 0, 288, g, 0, e.work, { bits: 9 }), a = 0; a < 32; )
          e.lens[a++] = 5;
        e0(2, e.lens, 0, 32, p, 0, e.work, { bits: 5 }), (eA = !1);
      }
      (e.lencode = g), (e.lenbits = 9), (e.distcode = p), (e.distbits = 5);
    },
    eT = function t(e, a, i, n) {
      var r,
        s = e.state;
      return (
        null === s.window &&
          ((s.wsize = 1 << s.wbits),
          (s.wnext = 0),
          (s.whave = 0),
          (s.window = new Uint8Array(s.wsize))),
        n >= s.wsize
          ? (s.window.set(a.subarray(i - s.wsize, i), 0),
            (s.wnext = 0),
            (s.whave = s.wsize))
          : ((r = s.wsize - s.wnext) > n && (r = n),
            s.window.set(a.subarray(i - n, i - n + r), s.wnext),
            (n -= r)
              ? (s.window.set(a.subarray(i - n, i), 0),
                (s.wnext = n),
                (s.whave = s.wsize))
              : ((s.wnext += r),
                s.wnext === s.wsize && (s.wnext = 0),
                s.whave < s.wsize && (s.whave += r))),
        0
      );
    },
    eF = {
      inflateReset: e7,
      inflateReset2: eS,
      inflateResetKeep: eZ,
      inflateInit: function t(e) {
        return eD(e, 15);
      },
      inflateInit2: eD,
      inflate: function t(e, a) {
        var i,
          n,
          r,
          s,
          $,
          o,
          f,
          l,
          h,
          d,
          _,
          u,
          c,
          w,
          b,
          g,
          p,
          m,
          x,
          v,
          k,
          y,
          z,
          E,
          R = 0,
          Z = new Uint8Array(4),
          S = new Uint8Array([
            16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
          ]);
        if (!e || !e.state || !e.output || (!e.input && 0 !== e.avail_in))
          return ev;
        12 === (i = e.state).mode && (i.mode = 13),
          ($ = e.next_out),
          (r = e.output),
          (f = e.avail_out),
          (s = e.next_in),
          (n = e.input),
          (o = e.avail_in),
          (l = i.hold),
          (h = i.bits),
          (d = o),
          (_ = f),
          (y = ep);
        inf_leave: for (;;)
          switch (i.mode) {
            case 1:
              if (0 === i.wrap) {
                i.mode = 13;
                break;
              }
              for (; h < 16; ) {
                if (0 === o) break inf_leave;
                o--, (l += n[s++] << h), (h += 8);
              }
              if (2 & i.wrap && 35615 === l) {
                (i.check = 0),
                  (Z[0] = 255 & l),
                  (Z[1] = (l >>> 8) & 255),
                  (i.check = q(i.check, Z, 2, 0)),
                  (l = 0),
                  (h = 0),
                  (i.mode = 2);
                break;
              }
              if (
                ((i.flags = 0),
                i.head && (i.head.done = !1),
                !(1 & i.wrap) || (((255 & l) << 8) + (l >> 8)) % 31)
              ) {
                (e.msg = "incorrect header check"), (i.mode = 30);
                break;
              }
              if ((15 & l) !== e6) {
                (e.msg = "unknown compression method"), (i.mode = 30);
                break;
              }
              if (((l >>>= 4), (h -= 4), (k = (15 & l) + 8), 0 === i.wbits))
                i.wbits = k;
              else if (k > i.wbits) {
                (e.msg = "invalid window size"), (i.mode = 30);
                break;
              }
              (i.dmax = 1 << i.wbits),
                (e.adler = i.check = 1),
                (i.mode = 512 & l ? 10 : 12),
                (l = 0),
                (h = 0);
              break;
            case 2:
              for (; h < 16; ) {
                if (0 === o) break inf_leave;
                o--, (l += n[s++] << h), (h += 8);
              }
              if (((i.flags = l), (255 & i.flags) !== e6)) {
                (e.msg = "unknown compression method"), (i.mode = 30);
                break;
              }
              if (57344 & i.flags) {
                (e.msg = "unknown header flags set"), (i.mode = 30);
                break;
              }
              i.head && (i.head.text = (l >> 8) & 1),
                512 & i.flags &&
                  ((Z[0] = 255 & l),
                  (Z[1] = (l >>> 8) & 255),
                  (i.check = q(i.check, Z, 2, 0))),
                (l = 0),
                (h = 0),
                (i.mode = 3);
            case 3:
              for (; h < 32; ) {
                if (0 === o) break inf_leave;
                o--, (l += n[s++] << h), (h += 8);
              }
              i.head && (i.head.time = l),
                512 & i.flags &&
                  ((Z[0] = 255 & l),
                  (Z[1] = (l >>> 8) & 255),
                  (Z[2] = (l >>> 16) & 255),
                  (Z[3] = (l >>> 24) & 255),
                  (i.check = q(i.check, Z, 4, 0))),
                (l = 0),
                (h = 0),
                (i.mode = 4);
            case 4:
              for (; h < 16; ) {
                if (0 === o) break inf_leave;
                o--, (l += n[s++] << h), (h += 8);
              }
              i.head && ((i.head.xflags = 255 & l), (i.head.os = l >> 8)),
                512 & i.flags &&
                  ((Z[0] = 255 & l),
                  (Z[1] = (l >>> 8) & 255),
                  (i.check = q(i.check, Z, 2, 0))),
                (l = 0),
                (h = 0),
                (i.mode = 5);
            case 5:
              if (1024 & i.flags) {
                for (; h < 16; ) {
                  if (0 === o) break inf_leave;
                  o--, (l += n[s++] << h), (h += 8);
                }
                (i.length = l),
                  i.head && (i.head.extra_len = l),
                  512 & i.flags &&
                    ((Z[0] = 255 & l),
                    (Z[1] = (l >>> 8) & 255),
                    (i.check = q(i.check, Z, 2, 0))),
                  (l = 0),
                  (h = 0);
              } else i.head && (i.head.extra = null);
              i.mode = 6;
            case 6:
              if (
                1024 & i.flags &&
                ((u = i.length) > o && (u = o),
                u &&
                  (i.head &&
                    ((k = i.head.extra_len - i.length),
                    i.head.extra ||
                      (i.head.extra = new Uint8Array(i.head.extra_len)),
                    i.head.extra.set(n.subarray(s, s + u), k)),
                  512 & i.flags && (i.check = q(i.check, n, u, s)),
                  (o -= u),
                  (s += u),
                  (i.length -= u)),
                i.length)
              )
                break inf_leave;
              (i.length = 0), (i.mode = 7);
            case 7:
              if (2048 & i.flags) {
                if (0 === o) break inf_leave;
                u = 0;
                do
                  (k = n[s + u++]),
                    i.head &&
                      k &&
                      i.length < 65536 &&
                      (i.head.name += String.fromCharCode(k));
                while (k && u < o);
                if (
                  (512 & i.flags && (i.check = q(i.check, n, u, s)),
                  (o -= u),
                  (s += u),
                  k)
                )
                  break inf_leave;
              } else i.head && (i.head.name = null);
              (i.length = 0), (i.mode = 8);
            case 8:
              if (4096 & i.flags) {
                if (0 === o) break inf_leave;
                u = 0;
                do
                  (k = n[s + u++]),
                    i.head &&
                      k &&
                      i.length < 65536 &&
                      (i.head.comment += String.fromCharCode(k));
                while (k && u < o);
                if (
                  (512 & i.flags && (i.check = q(i.check, n, u, s)),
                  (o -= u),
                  (s += u),
                  k)
                )
                  break inf_leave;
              } else i.head && (i.head.comment = null);
              i.mode = 9;
            case 9:
              if (512 & i.flags) {
                for (; h < 16; ) {
                  if (0 === o) break inf_leave;
                  o--, (l += n[s++] << h), (h += 8);
                }
                if (l !== (65535 & i.check)) {
                  (e.msg = "header crc mismatch"), (i.mode = 30);
                  break;
                }
                (l = 0), (h = 0);
              }
              i.head &&
                ((i.head.hcrc = (i.flags >> 9) & 1), (i.head.done = !0)),
                (e.adler = i.check = 0),
                (i.mode = 12);
              break;
            case 10:
              for (; h < 32; ) {
                if (0 === o) break inf_leave;
                o--, (l += n[s++] << h), (h += 8);
              }
              (e.adler = i.check = e3(l)), (l = 0), (h = 0), (i.mode = 11);
            case 11:
              if (0 === i.havedict)
                return (
                  (e.next_out = $),
                  (e.avail_out = f),
                  (e.next_in = s),
                  (e.avail_in = o),
                  (i.hold = l),
                  (i.bits = h),
                  ex
                );
              (e.adler = i.check = 1), (i.mode = 12);
            case 12:
              if (a === eb || a === eg) break inf_leave;
            case 13:
              if (i.last) {
                (l >>>= 7 & h), (h -= 7 & h), (i.mode = 27);
                break;
              }
              for (; h < 3; ) {
                if (0 === o) break inf_leave;
                o--, (l += n[s++] << h), (h += 8);
              }
              switch (((i.last = 1 & l), (h -= 1), 3 & (l >>>= 1))) {
                case 0:
                  i.mode = 14;
                  break;
                case 1:
                  if ((eO(i), (i.mode = 20), a === eg)) {
                    (l >>>= 2), (h -= 2);
                    break inf_leave;
                  }
                  break;
                case 2:
                  i.mode = 17;
                  break;
                case 3:
                  (e.msg = "invalid block type"), (i.mode = 30);
              }
              (l >>>= 2), (h -= 2);
              break;
            case 14:
              for (l >>>= 7 & h, h -= 7 & h; h < 32; ) {
                if (0 === o) break inf_leave;
                o--, (l += n[s++] << h), (h += 8);
              }
              if ((65535 & l) != ((l >>> 16) ^ 65535)) {
                (e.msg = "invalid stored block lengths"), (i.mode = 30);
                break;
              }
              if (
                ((i.length = 65535 & l),
                (l = 0),
                (h = 0),
                (i.mode = 15),
                a === eg)
              )
                break inf_leave;
            case 15:
              i.mode = 16;
            case 16:
              if ((u = i.length)) {
                if ((u > o && (u = o), u > f && (u = f), 0 === u))
                  break inf_leave;
                r.set(n.subarray(s, s + u), $),
                  (o -= u),
                  (s += u),
                  (f -= u),
                  ($ += u),
                  (i.length -= u);
                break;
              }
              i.mode = 12;
              break;
            case 17:
              for (; h < 14; ) {
                if (0 === o) break inf_leave;
                o--, (l += n[s++] << h), (h += 8);
              }
              if (
                ((i.nlen = (31 & l) + 257),
                (l >>>= 5),
                (h -= 5),
                (i.ndist = (31 & l) + 1),
                (l >>>= 5),
                (h -= 5),
                (i.ncode = (15 & l) + 4),
                (l >>>= 4),
                (h -= 4),
                i.nlen > 286 || i.ndist > 30)
              ) {
                (e.msg = "too many length or distance symbols"), (i.mode = 30);
                break;
              }
              (i.have = 0), (i.mode = 18);
            case 18:
              for (; i.have < i.ncode; ) {
                for (; h < 3; ) {
                  if (0 === o) break inf_leave;
                  o--, (l += n[s++] << h), (h += 8);
                }
                (i.lens[S[i.have++]] = 7 & l), (l >>>= 3), (h -= 3);
              }
              for (; i.have < 19; ) i.lens[S[i.have++]] = 0;
              if (
                ((i.lencode = i.lendyn),
                (i.lenbits = 7),
                (z = { bits: i.lenbits }),
                (y = e0(0, i.lens, 0, 19, i.lencode, 0, i.work, z)),
                (i.lenbits = z.bits),
                y)
              ) {
                (e.msg = "invalid code lengths set"), (i.mode = 30);
                break;
              }
              (i.have = 0), (i.mode = 19);
            case 19:
              for (; i.have < i.nlen + i.ndist; ) {
                for (
                  ;
                  (b = (R = i.lencode[l & ((1 << i.lenbits) - 1)]) >>> 24),
                    (g = (R >>> 16) & 255),
                    (p = 65535 & R),
                    !(b <= h);

                ) {
                  if (0 === o) break inf_leave;
                  o--, (l += n[s++] << h), (h += 8);
                }
                if (p < 16) (l >>>= b), (h -= b), (i.lens[i.have++] = p);
                else {
                  if (16 === p) {
                    for (E = b + 2; h < E; ) {
                      if (0 === o) break inf_leave;
                      o--, (l += n[s++] << h), (h += 8);
                    }
                    if (((l >>>= b), (h -= b), 0 === i.have)) {
                      (e.msg = "invalid bit length repeat"), (i.mode = 30);
                      break;
                    }
                    (k = i.lens[i.have - 1]),
                      (u = 3 + (3 & l)),
                      (l >>>= 2),
                      (h -= 2);
                  } else if (17 === p) {
                    for (E = b + 3; h < E; ) {
                      if (0 === o) break inf_leave;
                      o--, (l += n[s++] << h), (h += 8);
                    }
                    (l >>>= b),
                      (h -= b),
                      (k = 0),
                      (u = 3 + (7 & l)),
                      (l >>>= 3),
                      (h -= 3);
                  } else {
                    for (E = b + 7; h < E; ) {
                      if (0 === o) break inf_leave;
                      o--, (l += n[s++] << h), (h += 8);
                    }
                    (l >>>= b),
                      (h -= b),
                      (k = 0),
                      (u = 11 + (127 & l)),
                      (l >>>= 7),
                      (h -= 7);
                  }
                  if (i.have + u > i.nlen + i.ndist) {
                    (e.msg = "invalid bit length repeat"), (i.mode = 30);
                    break;
                  }
                  for (; u--; ) i.lens[i.have++] = k;
                }
              }
              if (30 === i.mode) break;
              if (0 === i.lens[256]) {
                (e.msg = "invalid code -- missing end-of-block"), (i.mode = 30);
                break;
              }
              if (
                ((i.lenbits = 9),
                (z = { bits: i.lenbits }),
                (y = e0(1, i.lens, 0, i.nlen, i.lencode, 0, i.work, z)),
                (i.lenbits = z.bits),
                y)
              ) {
                (e.msg = "invalid literal/lengths set"), (i.mode = 30);
                break;
              }
              if (
                ((i.distbits = 6),
                (i.distcode = i.distdyn),
                (z = { bits: i.distbits }),
                (y = e0(2, i.lens, i.nlen, i.ndist, i.distcode, 0, i.work, z)),
                (i.distbits = z.bits),
                y)
              ) {
                (e.msg = "invalid distances set"), (i.mode = 30);
                break;
              }
              if (((i.mode = 20), a === eg)) break inf_leave;
            case 20:
              i.mode = 21;
            case 21:
              if (o >= 6 && f >= 258) {
                (e.next_out = $),
                  (e.avail_out = f),
                  (e.next_in = s),
                  (e.avail_in = o),
                  (i.hold = l),
                  (i.bits = h),
                  ed(e, _),
                  ($ = e.next_out),
                  (r = e.output),
                  (f = e.avail_out),
                  (s = e.next_in),
                  (n = e.input),
                  (o = e.avail_in),
                  (l = i.hold),
                  (h = i.bits),
                  12 === i.mode && (i.back = -1);
                break;
              }
              for (
                i.back = 0;
                (b = (R = i.lencode[l & ((1 << i.lenbits) - 1)]) >>> 24),
                  (g = (R >>> 16) & 255),
                  (p = 65535 & R),
                  !(b <= h);

              ) {
                if (0 === o) break inf_leave;
                o--, (l += n[s++] << h), (h += 8);
              }
              if (g && (240 & g) == 0) {
                for (
                  m = b, x = g, v = p;
                  (b =
                    (R = i.lencode[v + ((l & ((1 << (m + x)) - 1)) >> m)]) >>>
                    24),
                    (g = (R >>> 16) & 255),
                    (p = 65535 & R),
                    !(m + b <= h);

                ) {
                  if (0 === o) break inf_leave;
                  o--, (l += n[s++] << h), (h += 8);
                }
                (l >>>= m), (h -= m), (i.back += m);
              }
              if (
                ((l >>>= b), (h -= b), (i.back += b), (i.length = p), 0 === g)
              ) {
                i.mode = 26;
                break;
              }
              if (32 & g) {
                (i.back = -1), (i.mode = 12);
                break;
              }
              if (64 & g) {
                (e.msg = "invalid literal/length code"), (i.mode = 30);
                break;
              }
              (i.extra = 15 & g), (i.mode = 22);
            case 22:
              if (i.extra) {
                for (E = i.extra; h < E; ) {
                  if (0 === o) break inf_leave;
                  o--, (l += n[s++] << h), (h += 8);
                }
                (i.length += l & ((1 << i.extra) - 1)),
                  (l >>>= i.extra),
                  (h -= i.extra),
                  (i.back += i.extra);
              }
              (i.was = i.length), (i.mode = 23);
            case 23:
              for (
                ;
                (b = (R = i.distcode[l & ((1 << i.distbits) - 1)]) >>> 24),
                  (g = (R >>> 16) & 255),
                  (p = 65535 & R),
                  !(b <= h);

              ) {
                if (0 === o) break inf_leave;
                o--, (l += n[s++] << h), (h += 8);
              }
              if ((240 & g) == 0) {
                for (
                  m = b, x = g, v = p;
                  (b =
                    (R = i.distcode[v + ((l & ((1 << (m + x)) - 1)) >> m)]) >>>
                    24),
                    (g = (R >>> 16) & 255),
                    (p = 65535 & R),
                    !(m + b <= h);

                ) {
                  if (0 === o) break inf_leave;
                  o--, (l += n[s++] << h), (h += 8);
                }
                (l >>>= m), (h -= m), (i.back += m);
              }
              if (((l >>>= b), (h -= b), (i.back += b), 64 & g)) {
                (e.msg = "invalid distance code"), (i.mode = 30);
                break;
              }
              (i.offset = p), (i.extra = 15 & g), (i.mode = 24);
            case 24:
              if (i.extra) {
                for (E = i.extra; h < E; ) {
                  if (0 === o) break inf_leave;
                  o--, (l += n[s++] << h), (h += 8);
                }
                (i.offset += l & ((1 << i.extra) - 1)),
                  (l >>>= i.extra),
                  (h -= i.extra),
                  (i.back += i.extra);
              }
              if (i.offset > i.dmax) {
                (e.msg = "invalid distance too far back"), (i.mode = 30);
                break;
              }
              i.mode = 25;
            case 25:
              if (0 === f) break inf_leave;
              if (((u = _ - f), i.offset > u)) {
                if ((u = i.offset - u) > i.whave && i.sane) {
                  (e.msg = "invalid distance too far back"), (i.mode = 30);
                  break;
                }
                u > i.wnext
                  ? ((u -= i.wnext), (c = i.wsize - u))
                  : (c = i.wnext - u),
                  u > i.length && (u = i.length),
                  (w = i.window);
              } else (w = r), (c = $ - i.offset), (u = i.length);
              u > f && (u = f), (f -= u), (i.length -= u);
              do r[$++] = w[c++];
              while (--u);
              0 === i.length && (i.mode = 21);
              break;
            case 26:
              if (0 === f) break inf_leave;
              (r[$++] = i.length), f--, (i.mode = 21);
              break;
            case 27:
              if (i.wrap) {
                for (; h < 32; ) {
                  if (0 === o) break inf_leave;
                  o--, (l |= n[s++] << h), (h += 8);
                }
                if (
                  ((_ -= f),
                  (e.total_out += _),
                  (i.total += _),
                  _ &&
                    (e.adler = i.check =
                      i.flags
                        ? q(i.check, r, _, $ - _)
                        : X(i.check, r, _, $ - _)),
                  (_ = f),
                  (i.flags ? l : e3(l)) !== i.check)
                ) {
                  (e.msg = "incorrect data check"), (i.mode = 30);
                  break;
                }
                (l = 0), (h = 0);
              }
              i.mode = 28;
            case 28:
              if (i.wrap && i.flags) {
                for (; h < 32; ) {
                  if (0 === o) break inf_leave;
                  o--, (l += n[s++] << h), (h += 8);
                }
                if (l !== (4294967295 & i.total)) {
                  (e.msg = "incorrect length check"), (i.mode = 30);
                  break;
                }
                (l = 0), (h = 0);
              }
              i.mode = 29;
            case 29:
              y = em;
              break inf_leave;
            case 30:
              y = ek;
              break inf_leave;
            case 31:
              return e1;
            default:
              return ev;
          }
        return (
          (e.next_out = $),
          (e.avail_out = f),
          (e.next_in = s),
          (e.avail_in = o),
          (i.hold = l),
          (i.bits = h),
          (i.wsize ||
            (_ !== e.avail_out && i.mode < 30 && (i.mode < 27 || a !== ew))) &&
            eT(e, e.output, e.next_out, _ - e.avail_out),
          (d -= e.avail_in),
          (_ -= e.avail_out),
          (e.total_in += d),
          (e.total_out += _),
          (i.total += _),
          i.wrap &&
            _ &&
            (e.adler = i.check =
              i.flags
                ? q(i.check, r, _, e.next_out - _)
                : X(i.check, r, _, e.next_out - _)),
          (e.data_type =
            i.bits +
            (i.last ? 64 : 0) +
            (12 === i.mode ? 128 : 0) +
            (20 === i.mode || 15 === i.mode ? 256 : 0)),
          ((0 === d && 0 === _) || a === ew) && y === ep && (y = e4),
          y
        );
      },
      inflateEnd: function t(e) {
        if (!e || !e.state) return ev;
        var a = e.state;
        return a.window && (a.window = null), (e.state = null), ep;
      },
      inflateGetHeader: function t(e, a) {
        if (!e || !e.state) return ev;
        var i = e.state;
        return (2 & i.wrap) == 0 ? ev : ((i.head = a), (a.done = !1), ep);
      },
      inflateSetDictionary: function t(e, a) {
        var i,
          n,
          r,
          s = a.length;
        return e && e.state && (0 === (i = e.state).wrap || 11 === i.mode)
          ? 11 === i.mode && (n = X((n = 1), a, s, 0)) !== i.check
            ? ek
            : (r = eT(e, a, s, s))
            ? ((i.mode = 31), e1)
            : ((i.havedict = 1), ep)
          : ev;
      },
      inflateInfo: "pako inflate (from Nodeca project)",
    },
    eL = function t() {
      (this.text = 0),
        (this.time = 0),
        (this.xflags = 0),
        (this.os = 0),
        (this.extra = null),
        (this.extra_len = 0),
        (this.name = ""),
        (this.comment = ""),
        (this.hcrc = 0),
        (this.done = !1);
    },
    eN = Object.prototype.toString,
    eB = Q.Z_NO_FLUSH,
    eI = Q.Z_FINISH,
    eC = Q.Z_OK,
    eU = Q.Z_STREAM_END,
    eM = Q.Z_NEED_DICT,
    eH = Q.Z_STREAM_ERROR,
    eK = Q.Z_DATA_ERROR,
    ej = Q.Z_MEM_ERROR;
  function eP(t) {
    this.options = tj.assign(
      { chunkSize: 65536, windowBits: 15, to: "" },
      t || {}
    );
    var e = this.options;
    e.raw &&
      e.windowBits >= 0 &&
      e.windowBits < 16 &&
      ((e.windowBits = -e.windowBits),
      0 === e.windowBits && (e.windowBits = -15)),
      e.windowBits >= 0 &&
        e.windowBits < 16 &&
        !(t && t.windowBits) &&
        (e.windowBits += 32),
      e.windowBits > 15 &&
        e.windowBits < 48 &&
        (15 & e.windowBits) == 0 &&
        (e.windowBits |= 15),
      (this.err = 0),
      (this.msg = ""),
      (this.ended = !1),
      (this.chunks = []),
      (this.strm = new tJ()),
      (this.strm.avail_out = 0);
    var a = eF.inflateInit2(this.strm, e.windowBits);
    if (
      a !== eC ||
      ((this.header = new eL()),
      eF.inflateGetHeader(this.strm, this.header),
      e.dictionary &&
        ("string" == typeof e.dictionary
          ? (e.dictionary = tq.string2buf(e.dictionary))
          : "[object ArrayBuffer]" === eN.call(e.dictionary) &&
            (e.dictionary = new Uint8Array(e.dictionary)),
        e.raw && (a = eF.inflateSetDictionary(this.strm, e.dictionary)) !== eC))
    )
      throw Error(J[a]);
  }
  function eY(t, e) {
    var a = new eP(e);
    if ((a.push(t), a.err)) throw a.msg || J[a.err];
    return a.result;
  }
  (eP.prototype.push = function (t, e) {
    var a,
      i,
      n,
      r = this.strm,
      s = this.options.chunkSize,
      $ = this.options.dictionary;
    if (this.ended) return !1;
    for (
      i = e === ~~e ? e : !0 === e ? eI : eB,
        "[object ArrayBuffer]" === eN.call(t)
          ? (r.input = new Uint8Array(t))
          : (r.input = t),
        r.next_in = 0,
        r.avail_in = r.input.length;
      ;

    ) {
      for (
        0 === r.avail_out &&
          ((r.output = new Uint8Array(s)), (r.next_out = 0), (r.avail_out = s)),
          (a = eF.inflate(r, i)) === eM &&
            $ &&
            ((a = eF.inflateSetDictionary(r, $)) === eC
              ? (a = eF.inflate(r, i))
              : a === eK && (a = eM));
        r.avail_in > 0 && a === eU && r.state.wrap > 0 && 0 !== t[r.next_in];

      )
        eF.inflateReset(r), (a = eF.inflate(r, i));
      switch (a) {
        case eH:
        case eK:
        case eM:
        case ej:
          return this.onEnd(a), (this.ended = !0), !1;
      }
      if (((n = r.avail_out), r.next_out && (0 === r.avail_out || a === eU))) {
        if ("string" === this.options.to) {
          var o = tq.utf8border(r.output, r.next_out),
            f = r.next_out - o,
            l = tq.buf2string(r.output, o);
          (r.next_out = f),
            (r.avail_out = s - f),
            f && r.output.set(r.output.subarray(o, o + f), 0),
            this.onData(l);
        } else
          this.onData(
            r.output.length === r.next_out
              ? r.output
              : r.output.subarray(0, r.next_out)
          );
      }
      if (a !== eC || 0 !== n) {
        if (a === eU)
          return (
            (a = eF.inflateEnd(this.strm)), this.onEnd(a), (this.ended = !0), !0
          );
        if (0 === r.avail_in) break;
      }
    }
    return !0;
  }),
    (eP.prototype.onData = function (t) {
      this.chunks.push(t);
    }),
    (eP.prototype.onEnd = function (t) {
      t === eC &&
        ("string" === this.options.to
          ? (this.result = this.chunks.join(""))
          : (this.result = tj.flattenChunks(this.chunks))),
        (this.chunks = []),
        (this.err = t),
        (this.msg = this.strm.msg);
    });
  var eG = function t(e, a) {
      return ((a = a || {}).raw = !0), eY(e, a);
    },
    eX = { Inflate: eP, inflate: eY, inflateRaw: eG, ungzip: eY, constants: Q },
    eW = eh.Deflate,
    eq = eh.deflate,
    eJ = eh.deflateRaw,
    eQ = eh.gzip,
    eV = eX.Inflate,
    e9 = eX.inflate,
    at = eX.inflateRaw,
    ae = eX.ungzip,
    aa = eW,
    ai = eq,
    an = eJ,
    ar = eQ,
    as = eV,
    a$ = e9,
    ao = at,
    af = ae,
    al = Q;
  (t.Deflate = aa),
    (t.Inflate = as),
    (t.constants = al),
    (t.default = {
      Deflate: aa,
      deflate: ai,
      deflateRaw: an,
      gzip: ar,
      Inflate: as,
      inflate: a$,
      inflateRaw: ao,
      ungzip: af,
      constants: al,
    }),
    (t.deflate = ai),
    (t.deflateRaw = an),
    (t.gzip = ar),
    (t.inflate = a$),
    (t.inflateRaw = ao),
    (t.ungzip = af),
    Object.defineProperty(t, "__esModule", { value: !0 });
});
